import React, { useState, useEffect, useRef, useCallback } from 'react';
import { GoogleGenAI, Chat } from '@google/genai';
import { getTextApiKey } from '../services/geminiClient';
import { fileToBase64, fileToDataUrl } from '../utils/fileUtils';
import { dbGetAllDekaAiChats, dbSaveDekaAiChat, dbDeleteDekaAiChat, dbClearDekaAiHistory, Message, MessagePart, DekaAiHistory } from '../utils/db';
import { DKIcon, UploadIcon, XIcon, ArrowUpIcon, ClipboardIcon, CheckIcon, TrashIcon, ChevronDownIcon, MenuIcon, PencilIcon, CpuChipIcon } from './IconComponents';

const PROMPT_TEMPLATES: Record<string, { label: string; prompt: string }> = {
    'default': {
        label: "Asisten Umum DekaAI",
        prompt: `Kamu adalah DekaAI, asisten resmi aplikasi "DuniaKreator". Ngobrolnya santai aja ya. Selalu tanyain dulu buat klarifikasi kalau permintaan user kurang jelas. Kamu itu jago banget soal bikin konten dan semua fitur di DuniaKreator. Kalau ada yang minta tolong, kasih panduan langkah-langkah yang gampang. Kalau minta ide kreatif, kasih contoh yang konkret. Semua jawabanmu harus dalam Bahasa Indonesia yang santai dan enak dibaca (pakai markdown ya). Pastikan outputnya bersih, gak ada simbol atau karakter aneh.`
    },
    'person-to-video': {
        label: "Foto Karakter Jadi Video",
        prompt: `
Kamu adalah ahli prompt Veo 3 untuk membuat video dari foto orang (karakter). Ngobrol dengan user pakai Bahasa Indonesia yang santai, supaya gampang dipahami. Alurnya gini:
1. **Mulai Percakapan**: Sapa user dulu, lalu tanya: "Mau bikin video dari foto siapa? Orangnya lagi ngapain, di mana, dan suasananya kayak gimana?"
2. **Minta Foto**: Setelah user jawab, bilang: "Oke, keren! Boleh kirim fotonya sekarang?"
3. **Tanya Detail Aksi, Emosi, Latar Belakang**: Setelah foto diterima, analisis sekilas, lalu tanya lagi dengan lebih spesifik:
   - Aksinya seperti apa? (jalan, lari, duduk, melambaikan tangan, dll.)
   - Ekspresi/emosinya seperti apa? (senang, sedih, terkejut, marah, dll.)
   - Latar belakangnya seperti apa? (pantai, kota, hutan, studio, dll.)
4. **Tanya Dialog (opsional)**: Setelah user jawab semua itu, tanyakan: 
   - "Mau ada dialog/lip sync juga nggak di videonya?"
   - Kalau iya, lanjut tanya:
     > "Dialognya mau pakai bahasa apa? (misalnya: Bahasa Indonesia, Bahasa Inggris, Bahasa Jawa, dll.)"
     > "Logatnya seperti apa? (misalnya: Indonesia standar, Jawa Timur, Sunda, Betawi, dll.)"
5. **Tanya Durasi**: Setelah semua info lengkap, tanyakan juga: "Mau durasinya berapa detik? Nanti aku bagi jadi beberapa adegan ya, 1 adegan itu sekitar 8 detik di Veo."
6. **Proses & Buat Prompt**: Setelah semua info lengkap, buat prompt untuk setiap adegan (8 detik per adegan).
   - **WAJIB**: Prompt video final dalam Bahasa Inggris, detail, sinematik, dan dalam blok kode markdown terpisah supaya gampang disalin.
   - Setiap scene harus punya:
     - Deskripsi visual lengkap.
     - Info kamera (angle, lighting, close-up/dll.).
     - Format vertikal (9:16, 1080×1920).
     - Negative prompt (blurry, watermark, distorted, dll.).
     - Kalau ada dialog, tuliskan teks dialognya sesuai permintaan (tetap dalam bahasa & logat yang diinginkan user).

7. **Contoh Output Format:**
   Adegan 1:
   \`\`\`
   A hyperrealistic 8k digital photograph of a young woman wearing a red dress standing on a beach at sunset, smiling softly, the waves behind her shimmer with golden light. Camera: close-up, soft warm lighting, cinematic tone. Format: Vertical (portrait), 1080x1920, 9:16. Negative Prompt: blurry, watermark, distorted face, hand, reflection.
   \`\`\`
   Adegan 2:
   \`\`\`
   A hyperrealistic 8k digital photograph of the woman walking slowly along the shore, looking thoughtfully at the horizon, her dress fluttering in the breeze. Camera: side view, medium shot, soft golden light. Format: Vertical (portrait), 1080x1920, 9:16. Negative Prompt: blurry, watermark, distorted face, hand, reflection.
   \`\`\`
   Adegan 3:
   \`\`\`
   A hyperrealistic 8k digital photograph of the woman turning back and waving at the camera, her smile bright, with seagulls flying in the background. Camera: front view, slightly low angle, vibrant tones. Format: Vertical (portrait), 1080x1920, 9:16. She lip syncs in Javanese (East Java accent): “Halo rek, ayo dolan bareng nang kene!” Negative Prompt: blurry, watermark, distorted face, hand, reflection.
   \`\`\`
8. **Jaga Output Bersih**: Jangan sampai ada karakter aneh atau simbol tidak perlu di output.
`
    },
    'product-to-video': {
        label: "Foto Produk Jadi Video",
        prompt: `Kamu adalah ahli prompt Veo 3 untuk iklan produk. Kamu harus memandu user langkah demi langkah. Ngobrolnya pakai Bahasa Indonesia yang santai ya. Alurnya gini:
1.  **Mulai Percakapan**: Sapa user dan minta foto: tanyakan mau bikin video iklan produk seperti apa dan minta user kirim fotonya untuk di analisa.
2.  **Tanya Gaya Video**: Setelah user kirim foto, analisia, lalu tanyakan: "Sip, fotonya udah kuterima. Videonya mau ada narasi/dialog, atau mau fokus ke produknya aja yang gerak-gerak? Kalo produknya aja, mau dipegang tangan atau gerak sendiri?"
3.  **Tanya Durasi**: Setelah user jawab gaya videonya, tanyakan: "Oke, siap. Mau dibuat total berapa detik videonya? Nanti aku bagi jadi beberapa adegan ya, 1 adegan itu sekitar 8 detik di Veo."
4.  **Proses & Buat Prompt**: Setelah user kasih durasi, langsung proses. Buat prompt untuk setiap adegan (8 detik per adegan).
    - **PENTING**: Prompt video finalnya WAJIB dalam Bahasa Inggris (kecuali bagian dialognya), detail, dan sinematik.
    - **WAJIB**: Format setiap prompt adegan dalam blok kode markdown terpisah biar gampang disalin.
    - Setiap prompt adegan harus punya deskripsi visual, info kamera, format (selalu Vertikal 9:16), dan Negative Prompt.
    - Ikuti contoh format ini persis:
      - **Contoh Produk Gerak Sendiri (tanpa dialog):**
        Adegan 1:
        \`\`\`
        A hyperrealistic 8k digital photograph of a red remote control off-road racing car (number 34) placed on a sandy track, its wheels begin to spin as if coming alive. The car lights up slightly as dust rises around it. Camera: stationary, close-up on wheel, macro details. Format: Vertical (portrait), 1080x1920, 9:16. Negative Prompt: blurry, watermark, human face, hand, distorted, reflection.
        \`\`\`
        Adegan 2:
        \`\`\`
        A hyperrealistic 8k digital photograph of the red RC off-road car drifting sharply on a dirt curve, kicking up a cloud of dust, then performing a small jump over a ramp, looking dynamic and fast. Camera: side view tracking shot, crisp details, warm outdoor lighting. Format: Vertical (portrait), 1080x1920, 9:16. Negative Prompt: blurry, watermark, human face, hand, distorted, reflection.
        \`\`\`
      - **Contoh Dipegang Tangan (dengan dialog):**
        Adegan 1:
        \`\`\`
        A hyperrealistic 8k digital photograph of a human hand holding a red RC off-road car (number 34) above a wooden table, the hand gently rotates it to show details. Camera: POV close-up, soft warm light, vibrant color. Format: Vertical (portrait), 1080x1920, 9:16. He lip syncs in Indonesian: “Wah keren banget mobil remot ini, warnanya merah menyala!” Negative Prompt: blurry, watermark, human face, reflection.
        \`\`\`
        Adegan 2:
        \`\`\`
        A hyperrealistic 8k digital photograph of the hand placing the RC car on a sandy track, then pushing it slightly as the wheels start moving. Camera: POV close-up, outdoor light, realistic dust details. Format: Vertical (portrait), 1080x1920, 9:16. He lip syncs in Indonesian: “Lihat tuh bannya, siap buat off-road!” Negative Prompt: blurry, watermark, human face, reflection.
        \`\`\`
    - Pastikan outputnya bersih tanpa karakter aneh.`
    },
    'replicate-viral': {
        label: "Replika Konten Viral",
        prompt: `Kamu adalah DekaAI, seorang ahli pereplikasi video viral dan pakar prompt engineer untuk Google Veo 3. Tujuan utamamu adalah membantu pengguna menganalisis video yang mereka unggah dan membuat prompt Veo 3 yang super detail untuk menirunya semirip mungkin. Gunakan Bahasa Indonesia yang santai dan profesional.

**PENTING: Selalu mulai percakapan pertama dengan pesan ini, tanpa tambahan apapun:**
"Halo! Siap mereplika konten viral? Unggah video yang mau ditiru ya. **Info penting: biar hasilnya maksimal, videonya jangan lebih dari 15MB atau durasi video di atas 30 Detik ya.** Kalau lebih dari itu, mungkin hasilnya kurang akurat."

**Alur Percakapan & Tugasmu:**

1.  **Tunggu Video dari User**: Setelah mengirim pesan pembuka di atas, tunggu sampai user mengunggah video. Jangan tanya apa-apa lagi sebelum video diterima.

2.  **Analisis Video (Setelah Diunggah)**: Begitu user mengunggah video, tugasmu adalah menganalisisnya secara mendalam. Perhatikan:
    -   **Subjek & Karakter**: Siapa atau apa yang ada di video? Bagaimana penampilan mereka?
    -   **Lingkungan**: Di mana lokasinya? Waktu (pagi/siang/malam)? Cuaca?
    -   **Aksi**: Apa yang terjadi di setiap adegan?
    -   **Sinematografi**: Bagaimana pergerakan kamera, sudut pengambilan gambar, pencahayaan, dan gaya visualnya?
    -   **Audio**: Apa ada musik latar? Efek suara? Bagaimana mood-nya?
    -   **Dialog**: Apakah ada yang berbicara?

3.  **Konfirmasi & Minta Dialog & Music/Sound Effek (Jika Perlu)**: Setelah menganalisis, berikan ringkasan singkat hasil analisismu kepada user. Lalu tanyakan:
    -   "Oke, videonya udah aku analisis. Kelihatannya tentang [sebutkan ringkasan singkat]. Nah, untuk video replikanya nanti, kamu mau pakai dialog & Sound yang sama persis atau mau pakai dialog baru? Saran saya pakai dialog baru aja, biar natural, karena ini masih tahap uji coba. Kalau mau pakai dialog baru, silakan ketik di sini ya."

4.  **Buat Prompt Final**: Setelah user memberikan konfirmasi atau dialog baru, langsung buat prompt Veo 3.
    -   **Bagi menjadi Adegan 8 Detik**: Potong alur video menjadi beberapa adegan, di mana setiap adegan merepresentasikan sekitar 8 detik dari video asli.
    -   **Prompt per Adegan**: Untuk setiap adegan, buat satu blok prompt yang super detail.
    -   **WAJIB**: Prompt video final harus dalam **Bahasa Inggris** (kecuali bagian dialog), sangat detail, sinematik, dan menggunakan istilah-istilah teknis kamera/pencahayaan yang relevan.
    -   **WAJIB**: Setiap adegan harus dalam **blok kode markdown terpisah** agar mudah disalin.
    -   **Konsistensi**: Pastikan deskripsi karakter dan lingkungan konsisten di semua prompt adegan.
    -   **Aksi Karakter**: Pastikan Aksi Karakter Sangat Mirip Dengan Video Yang Di Analisa/dikirim user di semua prompt adegan.
    -   **Format Vertikal**: Asumsikan semua video viral adalah format vertikal (9:16).
    -   **Sertakan Audio & Dialog**: Deskripsikan audio (musik, sfx) dan sertakan dialog dengan format lip-sync yang benar.
    -   **Negative Prompt**: Sertakan negative prompt yang komprehensif.

5.  **Jaga Output Bersih**: Pastikan tidak ada karakter aneh atau simbol yang tidak perlu di output final.`
    },
    'optimize-story': {
        label: "Optimalkan Ide Cerita",
        prompt: `Kamu itu jagoannya nulis skenario dan 'dokter cerita'. Ngobrolnya santai. Kalau user kasih ide cerita simpel dalam Bahasa Indonesia, tanyain dulu konteks lainnya (misal: nuansa, genre, atau buat siapa ceritanya). Habis itu, kembangin idenya jadi cerita yang detail lengkap dengan karakter, motivasi, struktur 3 babak (awal, tengah, akhir), adegan kunci, dan contoh dialog. Hasilnya harus keren, detail, dan bersih dari simbol-simbol aneh.`
    },
    'marketing-idea': {
        label: "Buat Ide Marketing/Iklan",
        prompt: `Kamu itu ahli strategi marketing senior. Ngobrolnya santai. Kalau user ngasih produk atau jasa, tanya dulu target audiensnya siapa dan mau di platform apa (kalau belum jelas). Terus, kasih 3 ide kampanye iklan yang beda, kreatif, dan cocok buat sosmed Indonesia. Buat tiap ide, sertakan konsep inti, target audiens, slogan yang nempel, dan deskripsi singkat iklan videonya. Jawabannya pakai Bahasa Indonesia yang santai dan bersih ya.`
    },
    'viral-strategy': {
        label: "Rancang Konten Viral",
        prompt: `Kamu itu ahli strategi konten viral khusus pasar Indonesia. Ngobrolnya santai. Kalau user minta strategi biar viral, pastiin dulu dia mau pakai platform apa (TikTok, Reels, dll) dan suka bikin konten jenis apa. Terus, kasih strategi lengkap yang bisa langsung dipraktekin dalam Bahasa Indonesia: info audio dan format yang lagi tren, tips bikin hook kuat 3 detik pertama, cara cerita yang nyambung sama budaya lokal, strategi hashtag, dan waktu posting terbaik. Bikin jawabannya yang gampang diikuti dan bersih ya.`
    }
};


interface DekaAiModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface CustomTemplate {
  id: string;
  label: string;
  prompt: string;
}

const TypingIndicator: React.FC = () => (
    <div className="flex items-center gap-1.5 px-2">
        <div className="w-2 h-2 bg-brand-text-secondary rounded-full animate-bounce [animation-delay:-0.3s]"></div>
        <div className="w-2 h-2 bg-brand-text-secondary rounded-full animate-bounce [animation-delay:-0.15s]"></div>
        <div className="w-2 h-2 bg-brand-text-secondary rounded-full animate-bounce"></div>
    </div>
);

const CodeBlock: React.FC<{ language: string; code: string; onCopy: () => void; copied: boolean }> = ({ language, code, onCopy, copied }) => {
    return (
        <div className="bg-black/50 rounded-lg my-2 text-white">
            <div className="flex justify-between items-center px-4 py-1.5 bg-gray-700/50 rounded-t-lg">
                <span className="text-xs text-gray-400">{language || 'code'}</span>
                <button onClick={onCopy} className="flex items-center gap-1.5 text-xs text-gray-300 hover:text-white">
                    {copied ? <CheckIcon className="w-4 h-4 text-green-400" /> : <ClipboardIcon className="w-4 h-4" />}
                    {copied ? 'Tersalin' : 'Salin'}
                </button>
            </div>
            <pre className="p-4 text-sm whitespace-pre-wrap break-words overflow-x-auto">
                <code>{code}</code>
            </pre>
        </div>
    );
};

const renderTextWithMarkdown = (text: string) => {
  const lines = text.split('\n');
  const elements: React.ReactElement[] = [];
  let listType: 'ul' | 'ol' | null = null;
  let listItems: React.ReactElement[] = [];

  const flushList = () => {
    if (listItems.length > 0) {
      if (listType === 'ul') {
        elements.push(<ul key={`ul-${elements.length}`} className="list-disc list-inside my-2 pl-4">{listItems}</ul>);
      } else if (listType === 'ol') {
        elements.push(<ol key={`ol-${elements.length}`} className="list-decimal list-inside my-2 pl-4">{listItems}</ol>);
      }
      listItems = [];
      listType = null;
    }
  };

  const parseLine = (line: string) => {
    line = line.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    line = line.replace(/\*(.*?)\*/g, '<em>$1</em>');
    return <span dangerouslySetInnerHTML={{ __html: line }} />;
  };

  lines.forEach((line, index) => {
    const olMatch = line.match(/^\s*(\d+)\.\s+(.*)/);
    const ulMatch = line.match(/^\s*([*-])\s+(.*)/);
    const bqMatch = line.match(/^\s*>\s+(.*)/);

    if (olMatch) {
      if (listType !== 'ol') flushList();
      listType = 'ol';
      listItems.push(<li key={index}>{parseLine(olMatch[2])}</li>);
    } else if (ulMatch) {
      if (listType !== 'ul') flushList();
      listType = 'ul';
      listItems.push(<li key={index}>{parseLine(ulMatch[2])}</li>);
    } else if (bqMatch) {
      flushList();
      elements.push(<blockquote key={index} className="border-l-4 border-gray-500 pl-4 italic my-2">{parseLine(bqMatch[1])}</blockquote>);
    } else {
      flushList();
      if (line.trim() !== '') {
        elements.push(<p key={index} className="my-1">{parseLine(line)}</p>);
      } else {
        if (elements.length > 0 && (elements[elements.length - 1].props as { className?: string }).className?.includes('h-4') === false) {
           elements.push(<div key={index} className="h-4"></div>);
        }
      }
    }
  });

  flushList();
  return <>{elements}</>;
};


const MarkdownRenderer: React.FC<{ text: string; messageIndex: number }> = ({ text, messageIndex }) => {
    const [copiedStates, setCopiedStates] = useState<Record<string, boolean>>({});

    const handleCopy = (code: string, blockIndex: number) => {
        navigator.clipboard.writeText(code);
        setCopiedStates(prev => ({ ...prev, [`${messageIndex}-${blockIndex}`]: true }));
        setTimeout(() => {
            setCopiedStates(prev => ({ ...prev, [`${messageIndex}-${blockIndex}`]: false }));
        }, 2000);
    };
    
    const codeBlockRegex = /```(\w*)\n([\s\S]*?)\n```/g;
    
    const parts = [];
    let lastIndex = 0;
    let match;

    while ((match = codeBlockRegex.exec(text)) !== null) {
        if (match.index > lastIndex) {
            parts.push({ type: 'text', content: text.substring(lastIndex, match.index) });
        }
        parts.push({ type: 'code', language: match[1], content: match[2] });
        lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
        parts.push({ type: 'text', content: text.substring(lastIndex) });
    }

    return (
        <div className="prose prose-sm prose-invert max-w-none leading-relaxed">
            {parts.map((part, index) => {
                if (part.type === 'code') {
                    const blockKey = `${messageIndex}-${index}`;
                    return (
                        <CodeBlock
                            key={blockKey}
                            language={part.language}
                            code={part.content}
                            onCopy={() => handleCopy(part.content, index)}
                            copied={!!copiedStates[blockKey]}
                        />
                    );
                }
                return <div key={index}>{renderTextWithMarkdown(part.content)}</div>;
            })}
        </div>
    );
};


export const DekaAiModal: React.FC<DekaAiModalProps> = ({ isOpen, onClose }) => {
    const [chat, setChat] = useState<Chat | null>(null);
    const [messages, setMessages] = useState<Message[]>([]);
    const [input, setInput] = useState('');
    const [imageFile, setImageFile] = useState<File | null>(null);
    const [previewUrl, setPreviewUrl] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [selectedTemplate, setSelectedTemplate] = useState<string>('default');
    
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const [chatHistory, setChatHistory] = useState<DekaAiHistory[]>([]);
    const [activeChatId, setActiveChatId] = useState<string | null>(null);
    const [editingChat, setEditingChat] = useState<{id: string, title: string} | null>(null);
    const [copiedMessageId, setCopiedMessageId] = useState<number | null>(null);

    // Custom Chatbot States
    const [customTemplates, setCustomTemplates] = useState<CustomTemplate[]>([]);
    const [isCustomBotModalOpen, setIsCustomBotModalOpen] = useState(false);
    const [newBotName, setNewBotName] = useState('');
    const [newBotInstruction, setNewBotInstruction] = useState('');
    const [newBotInfo, setNewBotInfo] = useState('');
    
    const messagesEndRef = useRef<HTMLDivElement>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);
    const textareaRef = useRef<HTMLTextAreaElement>(null);

    const CUSTOM_TEMPLATES_KEY = 'duniakreator-custom-chatbots';

    const getCustomChatbotTemplates = (): CustomTemplate[] => {
      try {
        const stored = localStorage.getItem(CUSTOM_TEMPLATES_KEY);
        return stored ? JSON.parse(stored) : [];
      } catch (e) {
        return [];
      }
    };

    const saveCustomChatbotTemplates = (templates: CustomTemplate[]) => {
      localStorage.setItem(CUSTOM_TEMPLATES_KEY, JSON.stringify(templates));
    };

    const combinedTemplates = {
      ...PROMPT_TEMPLATES,
      ...customTemplates.reduce((acc, t) => {
        acc[t.id] = { label: t.label, prompt: t.prompt };
        return acc;
      }, {} as Record<string, { label: string; prompt: string }>)
    };
    
    const initializeChatInstance = useCallback((templateKey: string, history: Message[]): Chat | null => {
        try {
            const apiKey = getTextApiKey();
            const ai = new GoogleGenAI({ apiKey });
            const template = combinedTemplates[templateKey] || combinedTemplates['default'];
            
            const formattedHistory = history.map(msg => {
                const newParts = msg.parts.map(part => {
                    if (part.imageUrl && part.imageUrl.startsWith('data:')) {
                        const [header, data] = part.imageUrl.split(',');
                        const mimeMatch = header.match(/:(.*?);/);
                        if (mimeMatch && data) {
                            return { inlineData: { mimeType: mimeMatch[1], data } };
                        }
                    }
                    if (part.text) {
                        return { text: part.text };
                    }
                    return null; 
                }).filter(Boolean) as ({text: string} | {inlineData: {mimeType: string, data: string}})[];

                return { role: msg.role, parts: newParts };
            });

            const newChat = ai.chats.create({
                model: 'gemini-2.5-flash',
                config: { systemInstruction: template.prompt },
                history: formattedHistory
            });
            setChat(newChat);
            return newChat;
        } catch (e) {
            console.error(e);
            setError(e instanceof Error ? e.message : 'Gagal memulai sesi chat.');
            setChat(null);
            return null;
        }
    }, [customTemplates]);

    const startInitialConversation = async (chatInstance: Chat, chatData: DekaAiHistory) => {
        setIsLoading(true);
        setMessages([{ role: 'model', parts: [{ text: '' }] }]); // UI typing indicator
    
        try {
            const stream = await chatInstance.sendMessageStream({ message: "Sapa pengguna dengan ramah dan mulai percakapan sesuai dengan system prompt." });
    
            let fullResponseText = '';
            for await (const chunk of stream) {
                fullResponseText += chunk.text;
                setMessages([{ role: 'model', parts: [{ text: fullResponseText }] }]);
            }
    
            const modelMessage: Message = { role: 'model', parts: [{ text: fullResponseText }] };
            const newTitle = `Obrolan: ${combinedTemplates[chatData.templateKey]?.label || 'Umum'}`;
    
            const finalChatState: DekaAiHistory = {
                ...chatData,
                title: newTitle,
                messages: [modelMessage]
            };
    
            await dbSaveDekaAiChat(finalChatState);
            setChatHistory(prev => [finalChatState, ...prev.filter(c => c.id !== chatData.id)]);
    
        } catch (e) {
            console.error("Initial conversation failed:", e);
            const errorMessage = e instanceof Error ? e.message : "Gagal memulai percakapan";
            setMessages([{ role: 'model', parts: [{ text: `Error: ${errorMessage}` }] }]);
        } finally {
            setIsLoading(false);
        }
    };
    
    const createNewChat = async (templateKey: string = 'default') => {
        const newChatData: DekaAiHistory = {
            id: `chat-${Date.now()}`,
            title: "Memulai obrolan...",
            messages: [],
            createdAt: new Date().toISOString(),
            templateKey: templateKey
        };
        
        setActiveChatId(newChatData.id);
        setMessages([]);
        setSelectedTemplate(templateKey);
        setChatHistory(prev => [newChatData, ...prev]);
        
        const newChatInstance = initializeChatInstance(templateKey, []);
        
        if (newChatInstance) {
            await startInitialConversation(newChatInstance, newChatData);
        }
    };

    useEffect(() => {
        const loadData = async () => {
            const customBots = getCustomChatbotTemplates();
            setCustomTemplates(customBots);
            
            const history = await dbGetAllDekaAiChats();
            if (history.length > 0) {
                setChatHistory(history);
                const latestChat = history[0];
                setActiveChatId(latestChat.id);
                setMessages(latestChat.messages);
                setSelectedTemplate(latestChat.templateKey);
                initializeChatInstance(latestChat.templateKey, latestChat.messages);
            } else {
                await createNewChat(); 
            }
        };
        if (isOpen) {
            loadData();
        }
    }, [isOpen]);

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages, isLoading]);

    const handleTemplateChange = async (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newTemplateKey = e.target.value;
        await createNewChat(newTemplateKey);
    };

    const handleSendMessage = async () => {
        const currentChatId = activeChatId;
        if ((!input.trim() && !imageFile) || !chat || !currentChatId) return;

        // 1. Prepare user message & capture state
        const userMessageParts: MessagePart[] = [];
        if (input.trim()) userMessageParts.push({ text: input });
        if (previewUrl) userMessageParts.push({ imageUrl: previewUrl }); // This is now a data URL
        
        const userMessage: Message = { role: 'user', parts: userMessageParts };
        const typingIndicator: Message = { role: 'model', parts: [{ text: '' }] };
        const currentInput = input;
        const currentImageFile = imageFile;

        // 2. Optimistic UI update
        setMessages(prev => [...prev, userMessage, typingIndicator]);
        setInput('');
        setImageFile(null);
        setPreviewUrl(null);
        setIsLoading(true);
        setError(null);
    
        // 3. Prepare prompt parts for Gemini API
        const promptParts: (string | { inlineData: { mimeType: string; data: string } })[] = [];
        if (currentInput.trim()) promptParts.push(currentInput.trim());
        if (currentImageFile) {
            try {
                const base64Image = await fileToBase64(currentImageFile);
                promptParts.push({ inlineData: { mimeType: currentImageFile.type, data: base64Image } });
            } catch (e) {
                 const errorText = "Gagal memproses gambar.";
                 setMessages(prev => prev.slice(0, -1).concat([{ role: 'model', parts: [{ text: errorText }] }]));
                 setIsLoading(false);
                 return;
            }
        }
        
        // 4. Stream response from AI
        try {
            const stream = await chat.sendMessageStream({ message: promptParts });
            let fullResponseText = '';
            for await (const chunk of stream) {
                fullResponseText += chunk.text;
                setMessages(prev => {
                    const newMessages = [...prev];
                    if (newMessages.length > 0) {
                        newMessages[newMessages.length - 1] = { role: 'model', parts: [{ text: fullResponseText }] };
                    }
                    return newMessages;
                });
            }
    
            // 5. Once streaming is complete, update database and history state
            const modelMessage: Message = { role: 'model', parts: [{ text: fullResponseText }] };
            
            const currentChat = chatHistory.find(c => c.id === currentChatId);
            if (currentChat) {
                let newTitle = currentChat.title;
                const isFirstUserMessage = currentChat.messages.length <= 1;

                if (isFirstUserMessage && currentInput.trim() && (currentChat.title.startsWith("Memulai") || currentChat.title.startsWith("Obrolan Baru"))) {
                    try {
                        const titleAi = new GoogleGenAI({apiKey: getTextApiKey()});
                        const titleRes = await titleAi.models.generateContent({model: 'gemini-2.5-flash', contents: `Buat judul singkat (maksimal 5 kata) dalam Bahasa Indonesia untuk percakapan yang dimulai dengan: "${currentInput.trim()}"`});
                        newTitle = titleRes.text.trim().replace(/"/g, '') || `Obrolan: ${currentInput.substring(0, 20)}`;
                    } catch (titleError) {
                        console.error("Gagal membuat judul obrolan:", titleError);
                        newTitle = `Obrolan: ${currentInput.substring(0, 20)}`;
                    }
                }
                
                const finalChatState: DekaAiHistory = {
                    ...currentChat,
                    title: newTitle,
                    messages: [...currentChat.messages, userMessage, modelMessage]
                };
    
                await dbSaveDekaAiChat(finalChatState);
                setChatHistory(prev => {
                    const otherChats = prev.filter(c => c.id !== currentChatId);
                    return [finalChatState, ...otherChats];
                });
            }
    
        } catch (e) {
            console.error(e);
            const errorMessage = e instanceof Error ? e.message : "Terjadi kesalahan";
            const errorText = `Maaf, terjadi kesalahan: ${errorMessage}`;
            const errorModelMessage: Message = { role: 'model', parts: [{ text: errorText }] };
            setMessages(prev => prev.slice(0, -1).concat([errorModelMessage]));
            
            const currentChat = chatHistory.find(c => c.id === currentChatId);
            if (currentChat) {
                const errorChatState = { ...currentChat, messages: [...currentChat.messages, userMessage, errorModelMessage] };
                await dbSaveDekaAiChat(errorChatState);
                setChatHistory(prev => prev.map(c => c.id === currentChatId ? errorChatState : c));
            }
        } finally {
            setIsLoading(false);
        }
    };
    
    const handleSelectChat = (chatId: string) => {
        const selected = chatHistory.find(c => c.id === chatId);
        if (selected) {
            setActiveChatId(selected.id);
            setMessages(selected.messages);
            setSelectedTemplate(selected.templateKey);
            initializeChatInstance(selected.templateKey, selected.messages);
            setIsMenuOpen(false);
        }
    };
    
    const handleDeleteChat = async (chatId: string) => {
        if (window.confirm("Yakin ingin menghapus obrolan ini?")) {
            await dbDeleteDekaAiChat(chatId);
            const updatedHistory = chatHistory.filter(c => c.id !== chatId);
            setChatHistory(updatedHistory);
            if (activeChatId === chatId) {
                if (updatedHistory.length > 0) {
                    handleSelectChat(updatedHistory[0].id);
                } else {
                    await createNewChat();
                }
            }
        }
    };

    const handleUpdateChatTitle = async () => {
        if (!editingChat || !editingChat.title.trim()) return;
        const chatToUpdate = chatHistory.find(c => c.id === editingChat.id);
        if (chatToUpdate) {
            chatToUpdate.title = editingChat.title.trim();
            await dbSaveDekaAiChat(chatToUpdate);
            setChatHistory(prev => prev.map(c => c.id === editingChat.id ? chatToUpdate : c));
        }
        setEditingChat(null);
    };

    const handleCopyMessage = (msg: Message, index: number) => {
        const textToCopy = msg.parts.map(p => p.text).filter(Boolean).join('\n\n');
        if (textToCopy) {
            navigator.clipboard.writeText(textToCopy);
            setCopiedMessageId(index);
            setTimeout(() => setCopiedMessageId(null), 2000);
        }
    };
    
    const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) { 
            setImageFile(file); 
            try {
                const dataUrl = await fileToDataUrl(file);
                setPreviewUrl(dataUrl);
            } catch (err) {
                setError("Gagal memuat pratinjau gambar.");
                setImageFile(null);
                setPreviewUrl(null);
            }
        }
    };

    const handleClearAllChats = async () => {
        if (window.confirm("Apakah Anda yakin ingin menghapus SEMUA obrolan? Tindakan ini tidak dapat diurungkan.")) {
            await dbClearDekaAiHistory();
            setChatHistory([]);
            await createNewChat();
        }
    };

    const handleSaveCustomBot = () => {
        if (!newBotName.trim() || !newBotInstruction.trim()) {
            alert("Nama chatbot dan perintah khusus tidak boleh kosong.");
            return;
        }
        const fullPrompt = `${newBotInstruction}\n\n--- INFORMASI TAMBAHAN ---\n${newBotInfo}`;
        const newTemplate: CustomTemplate = {
            id: `custom-${Date.now()}`,
            label: newBotName,
            prompt: fullPrompt,
        };
        const updatedTemplates = [...customTemplates, newTemplate];
        saveCustomChatbotTemplates(updatedTemplates);
        setCustomTemplates(updatedTemplates);
        setNewBotName('');
        setNewBotInstruction('');
        setNewBotInfo('');
        setIsCustomBotModalOpen(false);
    };
    
     useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
        }
    }, [input]);

    if (!isOpen) return null;

    return (
        <>
            <div className="fixed inset-0 bg-black/70 flex items-end justify-center sm:items-center z-50 p-0 sm:p-4" onClick={onClose}>
                <div 
                    className="bg-brand-bg-light w-full h-full sm:h-[90vh] sm:max-w-2xl rounded-t-2xl sm:rounded-2xl border border-brand-border shadow-2xl flex flex-col animate-fade-in relative overflow-hidden"
                    onClick={e => e.stopPropagation()}
                >
                    {/* Chat History Sidebar */}
                    <div className={`absolute top-0 left-0 h-full w-64 bg-brand-bg-dark border-r border-brand-border z-20 transform transition-transform duration-300 ${isMenuOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                        <div className="p-2 flex flex-col h-full">
                            <button onClick={() => createNewChat(selectedTemplate)} className="w-full text-left p-2 mb-2 bg-brand-blue hover:bg-brand-blue-dark text-white rounded-lg font-semibold">
                                + Obrolan Baru
                            </button>
                            <div className="flex-grow overflow-y-auto space-y-1 pr-1">
                                {chatHistory.map(chatItem => (
                                    <div key={chatItem.id} className={`group flex items-center w-full rounded-md pr-2 ${activeChatId === chatItem.id ? 'bg-brand-bg-light' : 'hover:bg-brand-bg-light/50'}`}>
                                        {editingChat?.id === chatItem.id ? (
                                            <input
                                                type="text"
                                                value={editingChat.title}
                                                onChange={(e) => setEditingChat({ ...editingChat, title: e.target.value })}
                                                onBlur={handleUpdateChatTitle}
                                                onKeyDown={(e) => e.key === 'Enter' && handleUpdateChatTitle()}
                                                autoFocus
                                                className="flex-grow p-2 text-sm bg-brand-bg-light border border-brand-blue rounded-md"
                                            />
                                        ) : (
                                            <>
                                                <button onClick={() => handleSelectChat(chatItem.id)} className={`flex-grow text-left p-2 text-sm rounded-md truncate ${activeChatId === chatItem.id ? 'font-semibold text-white' : 'text-gray-200 group-hover:text-white'}`}>
                                                    {chatItem.title}
                                                </button>
                                                <div className="flex flex-shrink-0 text-gray-400">
                                                    <button onClick={() => setEditingChat({ id: chatItem.id, title: chatItem.title })} className="p-1 hover:text-white"><PencilIcon className="w-4 h-4" /></button>
                                                    <button onClick={() => handleDeleteChat(chatItem.id)} className="p-1 hover:text-red-400"><TrashIcon className="w-4 h-4" /></button>
                                                </div>
                                            </>
                                        )}
                                    </div>
                                ))}
                            </div>
                            <div className="mt-auto pt-2 border-t border-brand-border space-y-2">
                                <button onClick={() => { setIsCustomBotModalOpen(true); setIsMenuOpen(false); }} className="w-full flex items-center gap-2 p-2 text-sm text-brand-text-primary hover:bg-cyan-500/20 rounded-lg transition-colors">
                                    <CpuChipIcon className="w-4 h-4 text-cyan-400" />
                                    <span className="text-white">Buat Chatbot Custom</span>
                                </button>
                                <button onClick={handleClearAllChats} className="w-full flex items-center gap-2 p-2 text-sm text-red-400 hover:bg-red-500/20 rounded-lg transition-colors">
                                    <TrashIcon className="w-4 h-4" />
                                    <span>Hapus Semua Obrolan</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    {isMenuOpen && <div className="absolute inset-0 bg-black/50 z-10 sm:hidden" onClick={() => setIsMenuOpen(false)}></div>}

                    {/* Main Chat Area */}
                    <div className="flex flex-col h-full w-full">
                        <header className="flex justify-between items-center p-4 border-b border-brand-border flex-shrink-0">
                            <div className="flex items-center gap-3">
                                <button onClick={() => setIsMenuOpen(!isMenuOpen)} className="text-brand-text-secondary hover:text-white"><MenuIcon className="w-6 h-6"/></button>
                                <div className="w-8 h-8 rounded-full bg-gradient-to-br from-green-400 to-cyan-500 flex items-center justify-center flex-shrink-0">
                                    <DKIcon className="w-6 h-6 text-white"/>
                                </div>
                                <div>
                                    <h1 className="text-lg font-bold text-brand-text-primary">DekaAI Asisten</h1>
                                    <p className="text-xs text-brand-text-secondary -mt-1">{combinedTemplates[selectedTemplate]?.label || 'Asisten Umum'}</p>
                                </div>
                            </div>
                            <button onClick={onClose} className="bg-red-600 hover:bg-red-700 text-white rounded-md p-1 transition-colors" aria-label="Tutup"><XIcon className="w-5 h-5"/></button>
                        </header>
                        
                        <div className="relative flex-shrink-0 p-4 border-b border-brand-border">
                            <select
                                value={selectedTemplate}
                                onChange={handleTemplateChange}
                                className="w-full bg-brand-bg-dark border border-brand-border rounded-lg p-2.5 text-brand-text-primary text-sm focus:ring-2 focus:ring-brand-blue outline-none transition appearance-none"
                            >
                                <optgroup label="Template Bawaan">
                                    {Object.entries(PROMPT_TEMPLATES).map(([key, { label }]) => (
                                        <option key={key} value={key}>{label}</option>
                                    ))}
                                </optgroup>
                                {customTemplates.length > 0 && (
                                    <optgroup label="Template Custom">
                                        {customTemplates.map(template => (
                                            <option key={template.id} value={template.id}>{template.label}</option>
                                        ))}
                                    </optgroup>
                                )}
                            </select>
                            <ChevronDownIcon className="w-5 h-5 text-brand-text-secondary absolute right-6 top-1/2 -translate-y-1/2 pointer-events-none"/>
                        </div>

                        <main ref={messagesEndRef} className="p-4 flex-grow overflow-y-auto space-y-6">
                            {messages.map((msg, index) => (
                                <div key={index} className={`flex gap-3 ${msg.role === 'user' ? 'justify-end' : ''}`}>
                                    {msg.role === 'model' && <div className="w-8 h-8 rounded-full bg-gradient-to-br from-green-400 to-cyan-500 flex items-center justify-center flex-shrink-0"><DKIcon className="w-6 h-6 text-white"/></div>}
                                    <div className={`w-full max-w-lg rounded-2xl p-3 relative group ${msg.role === 'user' ? 'bg-brand-blue text-white' : 'bg-brand-bg-dark text-white'}`}>
                                        {msg.role === 'model' && (
                                            <button onClick={() => handleCopyMessage(msg, index)} className="absolute top-2 right-2 p-1 bg-brand-border/50 rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                                                {copiedMessageId === index ? <CheckIcon className="w-4 h-4 text-green-400" /> : <ClipboardIcon className="w-4 h-4" />}
                                            </button>
                                        )}
                                        {msg.parts.map((part, partIndex) => (
                                            <div key={partIndex}>
                                                {part.text && <MarkdownRenderer text={part.text} messageIndex={index} />}
                                                {part.imageUrl && <img src={part.imageUrl} alt="User upload" className="mt-2 rounded-lg max-w-full h-auto max-h-60" />}
                                            </div>
                                        ))}
                                        {isLoading && index === messages.length - 1 && msg.role === 'model' && msg.parts.every(p => !p.text) && <TypingIndicator />}
                                    </div>
                                </div>
                            ))}
                        </main>

                        <footer className="p-4 border-t border-brand-border flex-shrink-0 bg-brand-bg-light">
                            {error && <p className="text-xs text-red-400 mb-2 text-center">{error}</p>}
                            {previewUrl && (
                                <div className="relative w-24 h-24 mb-2 p-1 border border-brand-border rounded-lg bg-brand-bg-dark">
                                     {imageFile && imageFile.type.startsWith('video/') ? (
                                        <video src={previewUrl} className="w-full h-full object-cover rounded" controls={false} autoPlay loop muted />
                                    ) : (
                                        <img src={previewUrl} alt="Preview" className="w-full h-full object-cover rounded"/>
                                    )}
                                    <button onClick={() => { setImageFile(null); setPreviewUrl(null); }} className="absolute -top-2 -right-2 bg-red-600 text-white rounded-full p-0.5"><XIcon className="w-4 h-4"/></button>
                                </div>
                            )}
                            <div className="relative flex items-end gap-2">
                                <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" accept="image/*,video/mp4,video/quicktime,video/webm"/>
                                <button onClick={() => fileInputRef.current?.click()} className="p-3 bg-brand-bg-dark border border-brand-border rounded-lg text-brand-text-secondary hover:text-white"><UploadIcon className="w-5 h-5"/></button>
                                <textarea
                                    ref={textareaRef}
                                    value={input}
                                    onChange={(e) => setInput(e.target.value)}
                                    onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } }}
                                    placeholder="Ketik pesan Anda di sini..."
                                    className="w-full bg-brand-bg-dark border border-brand-border rounded-lg p-3 text-brand-text-primary focus:ring-2 focus:ring-brand-blue outline-none transition resize-none max-h-40"
                                    rows={1}
                                />
                                <button onClick={handleSendMessage} disabled={isLoading || (!input.trim() && !imageFile)} className="p-3 bg-brand-blue text-white rounded-lg disabled:bg-brand-blue-dark/50 disabled:cursor-not-allowed"><ArrowUpIcon className="w-5 h-5"/></button>
                            </div>
                        </footer>
                    </div>
                </div>
            </div>
            {isCustomBotModalOpen && (
                 <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-[60] p-4" onClick={() => setIsCustomBotModalOpen(false)}>
                    <div 
                        className="bg-brand-bg-light w-full max-w-md rounded-2xl border border-brand-border shadow-2xl flex flex-col animate-fade-in max-h-[90vh]"
                        onClick={e => e.stopPropagation()}
                    >
                        <header className="flex justify-between items-center p-4 border-b border-brand-border">
                            <h2 className="text-xl font-semibold text-brand-text-primary">Buat Chatbot Custom</h2>
                            <button onClick={() => setIsCustomBotModalOpen(false)} className="bg-red-600 hover:bg-red-700 text-white rounded-md p-1 transition-colors" aria-label="Tutup"><XIcon className="w-5 h-5"/></button>
                        </header>
                        <div className="p-6 space-y-4 overflow-y-auto">
                            <div>
                                <label className="block text-sm font-medium mb-1 text-brand-text-primary">Nama Chatbot</label>
                                <input type="text" value={newBotName} onChange={e => setNewBotName(e.target.value)} placeholder="cth: Ahli Copywriting" className="w-full bg-brand-bg-dark p-2 border border-brand-border rounded text-brand-text-primary focus:ring-2 focus:ring-brand-blue outline-none transition"/>
                            </div>
                             <div>
                                <label className="block text-sm font-medium mb-1 text-brand-text-primary">Perintah Khusus (System Prompt)</label>
                                <textarea value={newBotInstruction} onChange={e => setNewBotInstruction(e.target.value)} rows={5} placeholder="Kamu adalah ahli copywriting..." className="w-full bg-brand-bg-dark p-2 border border-brand-border rounded resize-y text-brand-text-primary focus:ring-2 focus:ring-brand-blue outline-none transition"/>
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1 text-brand-text-primary">Informasi Tambahan (Opsional)</label>
                                <textarea value={newBotInfo} onChange={e => setNewBotInfo(e.target.value)} rows={5} placeholder="Masukkan data, contoh, atau konteks tambahan di sini..." className="w-full bg-brand-bg-dark p-2 border border-brand-border rounded resize-y text-brand-text-primary focus:ring-2 focus:ring-brand-blue outline-none transition"/>
                            </div>
                        </div>
                        <footer className="p-4 border-t border-brand-border mt-auto">
                            <button onClick={handleSaveCustomBot} className="w-full bg-brand-blue hover:bg-brand-blue-dark text-white font-bold py-2 px-4 rounded-lg">Simpan Chatbot</button>
                        </footer>
                    </div>
                 </div>
            )}
        </>
    );
};
